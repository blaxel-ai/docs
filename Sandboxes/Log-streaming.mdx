---

title: 'Log streaming'

description: 'Access logs generated by a sandbox in real time.'

---

Logging provides developers with visibility into process outputs within sandboxes. You can retrieve logs either in batch or streaming.

<Tip>Complete code examples demonstrating all operations are available on Blaxel's GitHub: [in TypeScript](https://github.com/blaxel-ai/sdk-typescript/tree/main/tests/sandbox) and [in Python](https://github.com/blaxel-ai/sdk-python/tree/main/tests/integration/sandbox).</Tip>

<Accordion title="Set up authentication to Blaxel">

The Blaxel SDK authenticates with your workspace using credentials from these sources, in priority order:

1. when running on Blaxel, authentication is handled automatically
2. variables in your `.env` file (`BL_WORKSPACE` and `BL_API_KEY`, or see [this page](../Agents/Variables-and-secrets) for other authentication options). 
3. environment variables from your machine
4. configuration file created locally when you log in through [Blaxel CLI](../cli-reference/introduction) (or deploy on Blaxel)

When developing locally, the recommended method is to just **log in to your workspace with Blaxel CLI.** This allows you to run Blaxel SDK functions that will automatically connect to your workspace without additional setup. When you deploy on Blaxel, this connection persists automatically.

When running Blaxel SDK from a remote server that is not Blaxel-hosted, we recommend using environment variables as described in the third option above.

</Accordion>

## In batch

### Retrieve from the execution object

Logs for a [process](Processes) are available in the *process execution* object **if** the process is started with the `waitForCompletion: true` / `"wait_for_completion": True` parameter. 

Both standard output (stdout) and standard error (stderr) are surfaced:

<CodeGroup>

```typescript TypeScript
import { SandboxInstance } from "@blaxel/core";

const sandbox = await SandboxInstance.get("my-sandbox");

const process = await sandbox.process.exec({
  name: "hello-process",
  command: "echo 'Hello, World!'",
  waitForCompletion: true
});
console.log(process.logs);
```

```python Python
from blaxel.core import SandboxInstance

sandbox = await SandboxInstance.get("my-sandbox")

process = await sandbox.process.exec({
  "name": "hello-process",
  "command": "echo 'Hello, World!'",
  "waitForCompletion": True
})
print(process.logs)
```

</CodeGroup>

### Retrieve from a completed process name or ID

Retrieve logs for a specific [process](Processes) (using either its name or process ID) after it has completed execution. By default, this retrieves standard output (**stdout**) only:

<CodeGroup>

```typescript TypeScript
const process = await sandbox.process.exec({
  name: "hello-process",
  command: "echo 'Hello, World!'"
});

const logs = await sandbox.process.logs("hello-process");
```

```python Python
process = await sandbox.process.exec({
  "name": "hello-process",
  "command": "echo 'Hello, World!'"
})

logs = await sandbox.process.logs("hello-process")
```

</CodeGroup>

To retrieve standard error (**stderr**):

<CodeGroup>

```typescript TypeScript
const errorLogs = await sandbox.process.logs("hello-process", "stderr");
```

```python Python
error_logs = await sandbox.process.logs("hello-process", "stderr")
```

</CodeGroup>

To retrieve both *stderr* and *stdout*:

<CodeGroup>

```typescript TypeScript
const allLogs = await sandbox.process.logs("hello-process", "all");
```

```python Python
all_logs = await sandbox.process.logs("hello-process", "all")
```

</CodeGroup>

## Streaming

### Retrieve via a callback function

The callback handlers receive log entries in real-time as they're generated by the process:

- **onLog/on_log**: Receives complete log objects with additional metadata

This method ensures you get a full view, as it first **backfills with all past logs** before beginning the real-time stream.

This approach is ideal for long-running processes where you need to monitor progress or respond to specific log events during execution.

<CodeGroup>

```typescript TypeScript
await sandbox.process.exec({
  name: "streaming-demo",
  command: "echo 'Starting process'; sleep 2; echo 'Processing...'; sleep 2; echo 'Completed!
  onLog: (log) => {
    console.log(`LOG: ${JSON.stringify(log)}`);
  }
});
```

```python Python
def on_log(log):
    print(f"LOG: {log}")

await sandbox.process.exec({
    "name": "streaming-demo",
    "command": "echo 'Starting process'; sleep 2; echo 'Processing...'; sleep 2; echo 'Completed!'",
    "on_log": on_log
})
```

</CodeGroup>

### Retrieve from a process name or ID

Stream logs for a specific [process](Processes) (using either its name or process ID):

<CodeGroup>

```typescript TypeScript
// Start a long-running process
await sandbox.process.exec({
  name: "stream-demo",
  command: "sh -c 'for i in $(seq 1 5); do echo \"Output $i\"; sleep 1; done'"
});

const stream = sandbox.process.streamLogs("stream-demo", {
  onLog: (log) => console.log("Log:", log),
  onStdout: (stdout) => console.log("Stdout:", stdout),
  onStderr: (stderr) => console.log("Stderr:", stderr)
});

// Wait for completion and cleanup
await sandbox.process.wait("stream-demo");
stream.close();
```

```python Python
# Start a long-running process
await sandbox.process.exec({
  "name": "stream-demo",
  "command": "sh -c 'for i in $(seq 1 5); do echo \"Output $i\"; sleep 1; done'"
})

stream = sandbox.process.stream_logs("stream-demo", {
  "on_log": lambda log: print(f"Log: {log}"),
  "on_stdout": lambda stdout: print(f"Stdout: {stdout}"),
  "on_stderr": lambda stderr: print(f"Stderr: {stderr}")
})

# Wait for completion and cleanup
await sandbox.process.wait("stream-demo")
stream["close"]()
```
</CodeGroup>